# Hephaestus Implementation Guide - Part 1
## Overview & Core Combat Infrastructure (Phases 0-1)

---

## Document Overview

This is Part 1 of 4 in the complete Hephaestus implementation guide:
- **Part 1**: Overview + Phase 0 (Foundation) + Phase 1 (Core Combat) ‚Üê You are here
- **Part 2**: Phase 2 (Weapon Systems)
- **Part 3**: Phase 3 (Point Defense) + Phase 4 (Enemy AI)
- **Part 4**: Phase 5 (Polish & VFX) + Phase 6 (Balance & MVP Completion)

---

## Project Overview

**Game**: Hephaestus - Turn-based tactical space combat  
**Goal**: Complete functional prototype demonstrating core combat mechanics  
**Timeline**: 9-10 weeks with parallel development (15 weeks sequential)  
**Engine**: Unity 6000.2.10f1  
**Language**: C#

---

## How to Use This Guide

### Step Format
Each step follows this structure:
1. **Prerequisites** - What must be complete before starting
2. **Manual Tasks** - Things you do in Unity
3. **Claude Code Prompt** - Copy/paste prompt for Claude Code
4. **Testing Instructions** - How to verify it works
5. **Status Update** - What to document in IMPLEMENTATION_STATUS.md

### Parallel Development Indicators
- üîµ Blue - Can run parallel with red tracks
- üî¥ Red - Can run parallel with blue tracks
- üü¢ Green - Can run parallel with blue and red tracks
- üü° Yellow - Can run parallel with blue, red, and green tracks
- ‚ö´ Black - Must be done sequentially

### Status Tracking
After each step, update `IMPLEMENTATION_STATUS.md` with:
- ‚úÖ What was completed
- üìÅ New files created
- üîß Modified files
- üß™ Test results
- ‚è≠Ô∏è Next step number
- üöß Any blockers or notes

---

## Phase 0: Foundation ‚úÖ COMPLETE

### Existing Systems (Already Implemented)

Your existing systems are working:
- ‚úì Turn-based gameplay (Command/Simulation phases)
- ‚úì Bezier curve movement with projections
- ‚úì Movement constraints (5-20 units, 45¬∞ turn)
- ‚úì Path visualization with collision detection
- ‚úì Homeworld-style orbit camera
- ‚úì Ship selection and input handling
- ‚úì Automatic phase transitions

**Key Files**:
- `Ship.cs` - Movement planning and execution
- `MovementController.cs` - Player input handling
- `TurnManager.cs` - Phase management
- `OrbitCamera.cs` - Camera control

**Confirm these work before proceeding to Phase 1.**

---

## Phase 1: Core Combat Infrastructure (Weeks 1-2)

### Overview
Phase 1 implements the foundation of combat: heat-based resource management and the ability system. These two systems can be developed in parallel and then integrated.

**Parallel Development**: 2 agents can work simultaneously
- üîµ Track A: Heat System
- üî¥ Track B: Ability System

**Timeline**: 1-2 weeks with parallel development

---

### Pre-Phase Manual Setup

#### MANUAL TASK 1.0: Create Project Structure
**Time**: 10 minutes

**Steps**:

1. In Unity, create new folders:
```
Assets/Scripts/Combat/
Assets/Scripts/Combat/Abilities/
Assets/Scripts/UI/
Assets/Tests/
Assets/Prefabs/UI/
```

2. Install Unity Test Framework:
   - Window ‚Üí Package Manager
   - Search "Test Framework"
   - Install if not already installed

3. Create test assembly:
   - Right-click `Assets/Tests/` ‚Üí Create ‚Üí Testing ‚Üí Tests Assembly Folder
   - Name it "PlayModeTests"

4. Create `IMPLEMENTATION_STATUS.md` in project root:

```markdown
# Hephaestus - Implementation Status

## Current Phase: 1.1 - Heat System
## Last Updated: [Date]

### Completed Steps
- Phase 0: Foundation ‚úÖ

### In Progress
- Step 1.1: Heat System Foundation

### Blockers
None

### Next Steps
- Complete Step 1.1
- Begin Step 1.2 (can run parallel)
```

**Status Update**: Document folder structure created

---

### Step 1.1: Heat System Foundation üîµ
**Parallel Track A** - Can run parallel with Step 1.2

**Prerequisites**: 
- Phase 0 complete
- Project structure created

**Time Estimate**: 4-6 hours

---

#### CLAUDE CODE PROMPT 1.1

```
CONTEXT:
I'm implementing Phase 1 of the Hephaestus space combat prototype. We have a working movement system with turn-based gameplay (Command/Simulation phases), but no combat mechanics yet.

Existing files you'll need to integrate with:
- Assets/Scripts/Movement/Ship.cs - Handles movement planning and execution
- Assets/Scripts/Movement/TurnManager.cs - Manages Command/Simulation phase transitions
- Assets/Scripts/Movement/MovementController.cs - Player input handling

OBJECTIVE:
Implement the Heat System - the core resource management mechanic for the game. Heat is generated by weapons and abilities, accumulates over time, and applies escalating penalties if it gets too high.

ARCHITECTURE REQUIREMENTS:

1. CREATE: Assets/Scripts/Combat/HeatManager.cs
   - Component that attaches to Ship GameObject
   - Properties:
     * MaxHeat: float (default 150)
     * CurrentHeat: float (tracks actual heat, starts at 0)
     * PlannedHeat: float (preview of heat from queued actions)
     * PassiveCooling: float (default 20, applied each turn)
   
   - Heat Tiers (enum):
     * Safe: 0-59 (no penalties)
     * Minor: 60-79 (-10% accuracy)
     * Moderate: 80-99 (-20% accuracy, -10% speed, sensor flicker)
     * Severe: 100-119 (-40% accuracy, -25% speed, systems glitching)
     * Critical: 120-149 (-60% accuracy, -40% speed, 5 hull dmg/turn)
     * Catastrophic: 150+ (-80% accuracy, -50% speed, 20 hull dmg/turn)
   
   - Methods:
     * AddPlannedHeat(float amount) - Add to planned heat (for UI preview)
     * CommitPlannedHeat() - Transfer planned to current heat
     * ClearPlannedHeat() - Reset planned heat (if action cancelled)
     * ApplyPassiveCooling() - Subtract PassiveCooling from CurrentHeat
     * InstantCooling(float amount) - Immediate heat reduction
     * GetCurrentTier() - Return current HeatTier enum
     * GetPenalties() - Return HeatPenalties struct with current multipliers
   
   - Events:
     * OnHeatChanged(float newHeat)
     * OnHeatTierChanged(HeatTier newTier)
   
   - HeatPenalties struct:
     * AccuracyMultiplier (1.0 to 0.2)
     * SpeedMultiplier (1.0 to 0.5)
     * HullDamagePerTurn (0 to 20)
     * SensorFlicker (bool)

2. CREATE: Assets/Scripts/UI/HeatDisplay.cs
   - UI component showing three-layer heat bar
   - Layers:
     * Current Heat: Solid color (green‚Üíyellow‚Üíorange‚Üíred based on tier)
     * Planned Heat: Semi-transparent overlay showing current + planned
     * Preview Heat: Very light overlay (only on hover)
   - Numeric display: "40/150" with "+20 Planned" if applicable
   - Tooltip on hover: Breakdown of heat sources
   - Position: Top-center, always visible
   - Color transitions smooth between tiers

3. MODIFY: Assets/Scripts/Movement/Ship.cs
   - Add combat properties:
     * MaxHull (float, default 500)
     * CurrentHull (float, starts at MaxHull)
     * MaxShields (float, default 200)
     * CurrentShields (float, starts at MaxShields)
     * ShieldRegenRate (float, default 20)
     * HeatManager (component reference)
   
   - Add methods:
     * TakeDamage(float damage) - Apply damage (shields first, then hull)
     * RegenerateShields() - Called each turn, add ShieldRegenRate to CurrentShields
     * ApplyHeatPenalties() - Modify movement speed based on HeatManager penalties
     * ApplyHeatDamage() - Apply hull damage if heat in Critical/Catastrophic
     * Die() - Destroy ship, trigger death event
   
   - Integrate with existing ExecuteMove():
     * Apply speed penalty from HeatManager when calculating movement interpolation

4. MODIFY: Assets/Scripts/Movement/TurnManager.cs
   - At end of Simulation phase:
     * Call HeatManager.ApplyPassiveCooling() on all ships
     * Call Ship.RegenerateShields() on all ships
     * Call Ship.ApplyHeatDamage() on all ships
   
   - Track all ships in scene (find all Ship components on Start)

INTEGRATION NOTES:
- HeatManager should be added to Ship GameObject in prefab
- Heat penalties affect movement speed by modifying interpolation speed
- For now, accuracy penalties won't have visible effect (weapons not implemented yet)
- Hull damage from heat applies after movement completes

TESTING REQUIREMENTS:

Unit Tests (create in Assets/Tests/PlayModeTests/HeatSystemTests.cs):
1. Test_HeatAccumulation - Add heat, verify CurrentHeat increases
2. Test_PassiveCooling - Apply cooling, verify heat decreases by 20
3. Test_HeatTiers - Verify correct tier at each threshold
4. Test_HeatPenalties - Verify penalty values at each tier
5. Test_PlannedHeat - Add planned heat, verify preview, commit, verify current
6. Test_InstantCooling - Apply instant cooling, verify immediate reduction
7. Test_HullDamageFromHeat - Set heat to 120, apply damage, verify hull decreased
8. Test_ShieldRegeneration - Damage shields, regenerate, verify increase
9. Test_ShipDeath - Reduce hull to 0, verify Die() called
10. Test_HeatEvents - Subscribe to events, verify they fire on heat changes

Manual Testing Instructions:
1. Create test scene with single Ship GameObject
2. Add HeatDisplay UI element (Canvas ‚Üí UI ‚Üí Image for heat bar)
3. Add test UI buttons to manually:
   - Add +20 heat
   - Add +50 heat
   - Apply instant cooling -50
   - Damage ship -100
   - End turn (triggers cooling and regen)
4. Observe:
   - Heat bar updates correctly (color changes)
   - Numeric display accurate
   - Ship takes hull damage at 120+ heat
   - Passive cooling applies each turn
   - Shield regeneration works
   - Ship movement slows at high heat

DELIVERABLES:
1. HeatManager.cs with all methods and properties
2. HeatDisplay.cs with three-layer UI visualization
3. Modified Ship.cs with combat stats and heat integration
4. Modified TurnManager.cs with cooling/regen calls
5. HeatSystemTests.cs with 10 unit tests (all passing)
6. Test scene setup for manual testing

STATUS UPDATE:
After completing this task, update IMPLEMENTATION_STATUS.md with:
- ‚úÖ Step 1.1 Complete - Heat System Foundation
- üìÅ New Files: HeatManager.cs, HeatDisplay.cs, HeatSystemTests.cs
- üîß Modified Files: Ship.cs, TurnManager.cs
- üß™ Unit Tests: 10/10 passing
- üéÆ Manual Test: Heat bar displays, penalties apply, cooling works
- ‚è≠Ô∏è Next Step: 1.2 (Ability System) or Integration 1.3
- üöß Notes: [Any issues or observations]

Begin implementation now.
```

---

#### MANUAL TESTING 1.1
**Time**: 15 minutes

**After Claude Code completes:**

1. Open Unity test scene
2. Add HeatDisplay to Canvas
3. Create test buttons:
   - "Add Heat +20"
   - "Add Heat +50"
   - "Cool -50"
   - "Damage -100"
   - "End Turn"
4. Wire up buttons to HeatManager methods
5. Test all functionality:

**Checklist**:
- [ ] Heat bar shows current heat visually
- [ ] Colors transition through tiers (green‚Üíyellow‚Üíorange‚Üíred)
- [ ] Numeric display accurate
- [ ] Planned heat shows as overlay
- [ ] Passive cooling works on "End Turn"
- [ ] Hull damage applies at 120+ heat
- [ ] Ship movement slows at high heat
- [ ] Shield regeneration works
- [ ] All 10 unit tests pass

**If all tests pass, proceed to Step 1.2**

---

### Step 1.2: Ability System Foundation üî¥
**Parallel Track B** - Can run parallel with Step 1.1

**Prerequisites**:
- Phase 0 complete
- Project structure created
- Step 1.1 can provide HeatManager interface (or use stub)

**Time Estimate**: 6-8 hours

---

#### MANUAL TASK 1.2A: Create Interface Definition
**Time**: 5 minutes

If Step 1.1 is still in progress, create this stub:

**Create**: `Assets/Scripts/Combat/IHeatManager.cs`

```csharp
public interface IHeatManager
{
    float CurrentHeat { get; }
    float MaxHeat { get; }
    float PlannedHeat { get; }
    void AddPlannedHeat(float amount);
    void CommitPlannedHeat();
    void ClearPlannedHeat();
    bool CanAffordHeat(float amount);
}
```

This allows ability system to develop independently.

---

#### CLAUDE CODE PROMPT 1.2

```
CONTEXT:
I'm implementing Phase 1 of the Hephaestus space combat prototype. The Heat System (Step 1.1) is [complete/in progress]. We need the Ability System that uses heat as a resource along with cooldowns.

Existing files:
- Assets/Scripts/Movement/Ship.cs - Ship behavior
- Assets/Scripts/Movement/TurnManager.cs - Phase management
- Assets/Scripts/Combat/HeatManager.cs - Heat tracking [or IHeatManager.cs interface if parallel]

OBJECTIVE:
Implement the Ability System - a flexible framework for special ship abilities with heat costs, cooldowns, and spin-up delays during execution.

ARCHITECTURE REQUIREMENTS:

1. CREATE: Assets/Scripts/Combat/Abilities/Ability.cs (abstract base class)
   - MonoBehaviour that attaches to Ship
   - Properties:
     * AbilityName: string
     * HeatCost: int
     * MaxCooldown: int
     * CurrentCooldown: int (starts at 0)
     * SpinUpTime: float (activation delay in seconds)
     * IsReady: bool (property, true if CurrentCooldown == 0)
     * CanAfford: bool (property, checks if ship can pay heat cost)
   
   - Protected:
     * ship: Ship (reference to owner)
     * isQueued: bool (marked for execution this turn)
   
   - Methods:
     * virtual void Initialize(Ship owner) - Set ship reference
     * bool TryActivate() - Queue ability if ready and affordable
     * abstract IEnumerator ExecuteWithSpinUp() - Coroutine: wait SpinUpTime, then Execute()
     * abstract void Execute() - Apply ability effect
     * void TickCooldown() - Decrease CurrentCooldown
     * void StartCooldown() - Set CurrentCooldown to MaxCooldown
     * virtual void Cancel() - Cancel queued ability (if ship destroyed)

2. CREATE: Assets/Scripts/Combat/Abilities/AbilitySystem.cs
   - Component on Ship GameObject
   - Manages all abilities on ship
   - Properties:
     * abilities: List<Ability>
     * queuedAbilities: List<Ability>
   
   - Methods:
     * void Start() - Find all Ability components, register them
     * bool TryActivateAbility(string abilityName)
     * IEnumerator ExecuteQueuedAbilities() - Called during Simulation
     * void TickAllCooldowns() - Called at end of turn
     * void ClearQueue()
     * Ability GetAbility(string name)
     * List<Ability> GetAllAbilities()

3. CREATE: Assets/Scripts/Combat/Abilities/EmergencyCooling.cs
   - Inherits from Ability
   - Settings: HeatCost=0, MaxCooldown=4, SpinUpTime=0.1f
   - Execute(): Call ship.HeatManager.InstantCooling(50)

4. CREATE: Assets/Scripts/Combat/Abilities/ShieldBoost.cs
   - Inherits from Ability
   - Settings: HeatCost=25, MaxCooldown=3, SpinUpTime=0.3f
   - Execute(): Add 100 to ship.CurrentShields, track temporary shields, remove after 2 turns

5. CREATE: Assets/Scripts/Combat/Abilities/EvasiveManeuver.cs
   - Inherits from Ability
   - Settings: HeatCost=35, MaxCooldown=2, SpinUpTime=0.0f (instant)
   - Execute(): Override ship movement constraints (90¬∞ turn, 30 unit move), reset after movement

6. CREATE: Assets/Scripts/Combat/Abilities/OverchargeWeapons.cs
   - Inherits from Ability
   - Settings: HeatCost=20, MaxCooldown=3, SpinUpTime=0.5f
   - Execute(): Set ship.WeaponDamageMultiplier = 1.5f, WeaponHeatMultiplier = 2.0f, reset at turn end

7. CREATE: Assets/Scripts/Combat/Abilities/SensorBurst.cs
   - Inherits from Ability
   - Settings: HeatCost=15, MaxCooldown=2, SpinUpTime=0.2f
   - Execute(): Reveal all enemy PlannedPosition/PlannedRotation until Simulation end

8. CREATE: Assets/Scripts/Combat/Abilities/PDOverride.cs
   - Inherits from Ability
   - Settings: HeatCost=30, MaxCooldown=3, SpinUpTime=0.3f
   - Execute(): Double PD MaxTargetsPerTurret (stub for now, PD not implemented yet)

9. CREATE: Assets/Scripts/UI/AbilityBarUI.cs
   - UI component showing 6 ability slots
   - Each slot displays:
     * Ability icon (colored squares for now)
     * Ability name
     * Hotkey number (1-6)
     * Cooldown timer overlay
     * Heat cost text
   - Visual states:
     * Available: Full brightness
     * On Cooldown: Grayed out + timer
     * Insufficient Heat: Yellow warning border
   - Layout: Horizontal bar, bottom of screen

10. MODIFY: Assets/Scripts/Movement/Ship.cs
    - Add properties:
      * AbilitySystem: AbilitySystem (component reference)
      * MovementConstraintsOverride: bool (for Evasive Maneuver)
      * WeaponDamageMultiplier: float (default 1.0)
      * WeaponHeatMultiplier: float (default 1.0)
    - Modify movement constraints check MovementConstraintsOverride

11. MODIFY: Assets/Scripts/Movement/TurnManager.cs
    - In StartSimulationPhase():
      * Call ship.AbilitySystem.ExecuteQueuedAbilities() on all ships
    - At end of Simulation phase:
      * Call ship.AbilitySystem.TickAllCooldowns() on all ships

12. MODIFY: Assets/Scripts/Movement/MovementController.cs
    - Add hotkey handling (number keys 1-6):
      * Call ship.AbilitySystem.TryActivateAbility(abilityName)

INTEGRATION NOTES:
- If HeatManager not complete, use IHeatManager interface with stub
- Abilities referencing unbuilt systems (WeaponSystem, PointDefenseSystem) should stub effects
- VFX are placeholders (Phase 5)
- Abilities queue in Command phase, execute in Simulation phase
- Use Unity coroutines for spin-up delays
- Cancel queued abilities if ship destroyed mid-spin-up

TESTING REQUIREMENTS:

Unit Tests (create in Assets/Tests/PlayModeTests/AbilitySystemTests.cs):
1. Test_AbilityActivation - Activate ability, verify queued
2. Test_AbilityCannotActivateOnCooldown - Try activate while on cooldown, verify fails
3. Test_AbilityCannotActivateInsufficientHeat - Try activate with low heat, verify fails
4. Test_AbilityCooldownTick - Start cooldown, tick, verify decreases
5. Test_AbilitySpinUp - Activate, verify Execute() called after SpinUpTime
6. Test_EmergencyCooling - Use ability, verify heat reduced by 50
7. Test_ShieldBoost - Use ability, verify shields increased, decay after 2 turns
8. Test_EvasiveManeuver - Use ability, verify movement constraints changed
9. Test_OverchargeWeapons - Use ability, verify multipliers set
10. Test_SensorBurst - Use ability, verify enemy positions revealed
11. Test_PDOverride - Use ability, verify PD rate doubled (stub)
12. Test_MultipleAbilitiesQueue - Queue 2 abilities, verify both execute
13. Test_AbilityInterruptOnDeath - Queue ability, destroy ship, verify cancelled

Manual Testing Instructions:
1. Create test scene with single Ship GameObject
2. Attach all 6 ability components to Ship
3. Add AbilityBarUI to Canvas
4. Add test UI buttons for each ability (1-6)
5. Add heat display (from Step 1.1)
6. Test:
   - Press number keys 1-6 to activate abilities
   - Verify abilities show in UI
   - Verify heat costs apply
   - Verify cooldowns prevent re-activation
   - Verify "insufficient heat" warning
   - Verify abilities execute after spin-up delay
   - Test Emergency Cooling reduces heat
   - Test Shield Boost increases shields temporarily
   - Test Evasive Maneuver changes movement constraints
   - Test multiple abilities can queue same turn

DELIVERABLES:
1. Ability.cs abstract base class
2. AbilitySystem.cs manager component
3. 6 concrete ability classes
4. AbilityBarUI.cs with 6-slot interface
5. Modified Ship.cs, TurnManager.cs, MovementController.cs
6. AbilitySystemTests.cs with 13 unit tests (all passing)
7. Test scene setup

STATUS UPDATE:
After completing this task, update IMPLEMENTATION_STATUS.md with:
- ‚úÖ Step 1.2 Complete - Ability System Foundation
- üìÅ New Files: Ability.cs, AbilitySystem.cs, 6 ability classes, AbilityBarUI.cs, AbilitySystemTests.cs
- üîß Modified Files: Ship.cs, TurnManager.cs, MovementController.cs
- üß™ Unit Tests: 13/13 passing
- üéÆ Manual Test: Abilities activate, heat costs apply, cooldowns work, UI displays correctly
- ‚è≠Ô∏è Next Step: Integration 1.3
- üöß Notes: [Any issues, especially if HeatManager was stubbed]

Begin implementation now.
```

---

#### MANUAL TESTING 1.2
**Time**: 20 minutes

**After Claude Code completes:**

1. Open test scene with Ship
2. Verify all 6 ability components attached
3. Add AbilityBarUI to Canvas
4. Test each ability:

**Checklist**:
- [ ] Press 1-6 keys to activate abilities
- [ ] Ability icons show in UI
- [ ] Cooldown timers display correctly
- [ ] Heat costs show and apply
- [ ] "Insufficient heat" warning when can't afford
- [ ] Abilities queue during Command phase
- [ ] Abilities execute during Simulation with spin-up delays
- [ ] Emergency Cooling reduces heat by 50
- [ ] Shield Boost adds temporary shields
- [ ] Evasive Maneuver changes movement limits
- [ ] Multiple abilities can queue same turn
- [ ] Cooldowns prevent re-activation
- [ ] All 13 unit tests pass

**If all tests pass, proceed to Integration 1.3**

---

### Step 1.3: Phase 1 Integration ‚ö´
**Sequential** - Must complete after Steps 1.1 AND 1.2

**Prerequisites**:
- Step 1.1 complete (Heat System)
- Step 1.2 complete (Ability System)

**Time Estimate**: 2-3 hours

---

#### CLAUDE CODE PROMPT 1.3

```
CONTEXT:
Phase 1 parallel development is complete. We have:
- Step 1.1: Heat System (HeatManager, HeatDisplay, heat integration)
- Step 1.2: Ability System (6 abilities, AbilitySystem, AbilityBarUI)

OBJECTIVE:
Integrate the two systems together, replacing any stubs, fixing any interface mismatches, and ensuring they work harmoniously.

FILES TO REVIEW AND INTEGRATE:
- Assets/Scripts/Combat/HeatManager.cs
- Assets/Scripts/Combat/Abilities/Ability.cs
- Assets/Scripts/Combat/Abilities/AbilitySystem.cs
- Assets/Scripts/Combat/Abilities/*.cs (all 6 ability implementations)
- Assets/Scripts/Movement/Ship.cs
- Assets/Scripts/Movement/TurnManager.cs
- Assets/Scripts/UI/HeatDisplay.cs
- Assets/Scripts/UI/AbilityBarUI.cs

INTEGRATION TASKS:

1. Replace IHeatManager stub (if used) with real HeatManager
   - Update Ability.cs to use HeatManager instead of interface
   - Verify CanAfford property uses HeatManager.CanAffordHeat()

2. Connect ability heat costs to HeatDisplay
   - When ability queued: HeatManager.AddPlannedHeat(HeatCost)
   - Verify HeatDisplay shows planned heat overlay
   - When ability executes: HeatManager.CommitPlannedHeat()
   - If cancelled: HeatManager.ClearPlannedHeat()

3. Verify TurnManager integration
   - Correct order:
     1. Start Simulation
     2. Execute movement
     3. Execute abilities (with spin-up delays)
     4. Apply passive cooling
     5. Tick ability cooldowns
     6. Apply heat damage
     7. Regenerate shields

4. Connect AbilityBarUI to HeatDisplay
   - Hovering over ability shows preview heat in HeatDisplay
   - When ability queued, HeatDisplay updates immediately

5. Test all 6 abilities with heat system
   - Emergency Cooling works at any heat level
   - Other abilities show planned heat before execution

6. Test ability + heat combinations
   - Queue multiple abilities, verify total planned heat accurate
   - Test overheating via abilities (heat > 150)
   - Test Emergency Cooling enables big moves next turn
   - Test heat penalties affect ship speed

TESTING REQUIREMENTS:

Integration Tests (create in Assets/Tests/PlayModeTests/Phase1IntegrationTests.cs):
1. Test_AbilityAddsPlannedHeat - Queue ability, verify HeatDisplay shows planned
2. Test_AbilityCommitsHeat - Execute ability, verify heat added to current
3. Test_AbilityCancelClearsPlannedHeat - Queue then cancel, verify planned cleared
4. Test_MultipleAbilitiesHeatStacking - Queue 3 abilities, verify total heat correct
5. Test_EmergencyCoolingAtHighHeat - Heat at 140, use Emergency Cooling, verify drops to 90
6. Test_AbilitiesPreventedByInsufficientHeat - Heat at 140, can't afford +25 ability
7. Test_TurnOrderCorrect - Verify: movement ‚Üí abilities ‚Üí cooling ‚Üí damage ‚Üí regen
8. Test_HeatPenaltiesWithAbilities - Use abilities to overheat, verify penalties apply
9. Test_AbilityHoverShowsPreview - Hover ability, verify preview heat in display
10. Test_ShieldBoostWithRegen - Use Shield Boost, verify regen still works on temp shields

Manual Testing Instructions:
1. Open integration test scene
2. Verify both UI elements visible (HeatDisplay + AbilityBarUI)
3. Execute these scenarios:
   
   SCENARIO A: Normal Combat Flow
   - Start turn (heat = 0)
   - Queue Shield Boost (+25 heat planned)
   - Queue Overcharge (+20 heat planned)
   - Verify HeatDisplay shows +45 planned
   - End turn (Simulation)
   - Verify abilities execute with spin-up delays
   - Verify heat becomes 45 after execution
   - Verify passive cooling reduces to 25 next turn
   
   SCENARIO B: Overheat Recovery
   - Manually set heat to 120 (Critical tier)
   - Verify ship takes hull damage each turn
   - Use Emergency Cooling
   - Verify heat drops to 70 (Safe tier)
   - Verify no more hull damage
   
   SCENARIO C: Heat Budget Management
   - Heat at 100
   - Try to queue Shield Boost (+25) and Evasive Maneuver (+35)
   - Verify warning that total exceeds safe threshold
   
   SCENARIO D: Multiple Abilities
   - Queue 3 different abilities same turn
   - Verify all show planned heat
   - Verify all execute in order during Simulation
   - Verify total heat accurate after all execute

DELIVERABLES:
1. Fully integrated Heat + Ability systems (no stubs)
2. HeatDisplay shows planned heat from queued abilities
3. AbilityBarUI shows heat costs and affordability
4. TurnManager executes both systems in correct order
5. Phase1IntegrationTests.cs with 10 tests (all passing)
6. Integration test scene demonstrating all features
7. Documentation of any issues found and resolved

STATUS UPDATE:
After completing this task, update IMPLEMENTATION_STATUS.md with:
- ‚úÖ Step 1.3 Complete - Phase 1 Integration
- ‚úÖ Phase 1 Complete - Core Combat Infrastructure
- üîß Modified Files: [List any files that needed integration fixes]
- üß™ Integration Tests: 10/10 passing
- üß™ Unit Tests Total: 23/23 passing (10 heat + 13 ability)
- üéÆ Manual Test: All scenarios pass, systems work together seamlessly
- ‚è≠Ô∏è Next Phase: Phase 2 - Weapon Systems (can start parallel development)
- üöß Notes: [Any observations about integration, performance, or future considerations]
- üìä Phase 1 Time: [Actual time taken]

Begin integration now.
```

---

#### MANUAL TESTING 1.3
**Time**: 30 minutes

**Full integration test:**

1. Open integration test scene
2. Verify all UI elements present and positioned correctly
3. Run through all 4 test scenarios (A, B, C, D) from prompt
4. Document any issues found
5. Verify all unit + integration tests pass (23 total)

**Checklist**:
- [ ] Heat and abilities work together
- [ ] Planned heat displays correctly
- [ ] Multiple abilities can queue
- [ ] Emergency Cooling works at critical heat
- [ ] Heat penalties apply correctly
- [ ] Turn execution order is correct
- [ ] No errors in console
- [ ] Performance is smooth (60 FPS)
- [ ] All 23 tests passing

**If all tests pass, Phase 1 is complete! Proceed to Phase 2**

---

## Phase 1 Summary

### What Was Built
- ‚úÖ Heat System: Core resource management with 6 tiers of penalties
- ‚úÖ Ability System: 6 abilities with heat costs and cooldowns
- ‚úÖ UI: Heat bar and ability bar with visual feedback
- ‚úÖ Integration: Both systems work harmoniously together

### Key Files Created
**Heat System (10 files)**:
- HeatManager.cs
- HeatDisplay.cs
- HeatSystemTests.cs
- Ship.cs extensions

**Ability System (13 files)**:
- Ability.cs (base)
- AbilitySystem.cs
- 6 ability implementations
- AbilityBarUI.cs
- AbilitySystemTests.cs
- Ship.cs, TurnManager.cs, MovementController.cs modifications

**Integration (1 file)**:
- Phase1IntegrationTests.cs

### Testing Summary
- Unit Tests: 23 (10 heat + 13 ability)
- Integration Tests: 10
- Manual Test Scenarios: 4
- **Total Tests: 33**

### Time Investment
- Parallel Development: 1-2 weeks
- Sequential Development: 2-3 weeks
- **Time Saved: ~1 week**

### Performance Baseline
- Target: 60 FPS maintained
- Memory: Stable, no leaks detected
- Test Duration: 30+ minute sessions stable

---

## Next Steps

With Phase 1 complete, you're ready to move to **Part 2** of this guide which covers Phase 2: Weapon Systems.

Phase 2 will implement:
- 4 weapon types (Rail Gun, Newtonian Cannon, Missiles, Torpedoes)
- Projectile physics system
- Targeting UI with weapon groups
- Complete combat loop

**Continue to Part 2 of the Implementation Guide**

---

## Appendix: Troubleshooting

### Common Phase 1 Issues

**Issue**: Heat bar not updating
- **Fix**: Verify HeatManager.OnHeatChanged event is subscribed by HeatDisplay

**Issue**: Abilities not executing during Simulation
- **Fix**: Check TurnManager calls AbilitySystem.ExecuteQueuedAbilities()

**Issue**: Planned heat not showing
- **Fix**: Verify AddPlannedHeat() called when ability queued

**Issue**: Movement speed not slowing at high heat
- **Fix**: Check Ship.ApplyHeatPenalties() modifies Bezier interpolation speed

**Issue**: Emergency Cooling on cooldown when shouldn't be
- **Fix**: Verify cooldowns tick at END of Simulation phase, not beginning

---

**End of Part 1**