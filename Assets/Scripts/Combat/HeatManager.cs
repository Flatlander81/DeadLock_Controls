using UnityEngine;
using System;
using System.Collections.Generic;

/// <summary>
/// Manages heat generation, accumulation, and cooling for a ship.
/// Heat is generated by weapons and abilities, and applies escalating penalties.
/// </summary>
public class HeatManager : MonoBehaviour
{
    /// <summary>
    /// Heat tier thresholds that determine penalty severity.
    /// </summary>
    public enum HeatTier
    {
        Safe,           // 0-59: No penalties
        Minor,          // 60-79: -10% accuracy
        Moderate,       // 80-99: -20% accuracy, -10% speed, sensor flicker
        Severe,         // 100-119: -40% accuracy, -25% speed, systems glitching
        Critical,       // 120-149: -60% accuracy, -40% speed, 5 hull dmg/turn
        Catastrophic    // 150+: -80% accuracy, -50% speed, 20 hull dmg/turn
    }

    /// <summary>
    /// Struct containing all current heat-based penalties.
    /// </summary>
    public struct HeatPenalties
    {
        public float AccuracyMultiplier;    // 1.0 to 0.2
        public float SpeedMultiplier;       // 1.0 to 0.5
        public float HullDamagePerTurn;     // 0 to 20
        public bool SensorFlicker;          // Visual effect flag
    }

    [Header("Heat Configuration")]
    [SerializeField] private float maxHeat = 150f;
    [SerializeField] private float passiveCooling = 20f;
    [SerializeField] private float overheatMultiplier = 2f;

    [Header("Heat Tier Thresholds")]
    [SerializeField] private float minorThreshold = 60f;
    [SerializeField] private float moderateThreshold = 80f;
    [SerializeField] private float severeThreshold = 100f;
    [SerializeField] private float criticalThreshold = 120f;
    [SerializeField] private float catastrophicThreshold = 150f;

    [Header("Penalty Settings - Minor Tier")]
    [SerializeField] private float minorAccuracyMult = 0.9f;
    [SerializeField] private float minorSpeedMult = 1.0f;

    [Header("Penalty Settings - Moderate Tier")]
    [SerializeField] private float moderateAccuracyMult = 0.8f;
    [SerializeField] private float moderateSpeedMult = 0.9f;

    [Header("Penalty Settings - Severe Tier")]
    [SerializeField] private float severeAccuracyMult = 0.6f;
    [SerializeField] private float severeSpeedMult = 0.75f;

    [Header("Penalty Settings - Critical Tier")]
    [SerializeField] private float criticalAccuracyMult = 0.4f;
    [SerializeField] private float criticalSpeedMult = 0.6f;
    [SerializeField] private float criticalHullDamage = 5f;

    [Header("Penalty Settings - Catastrophic Tier")]
    [SerializeField] private float catastrophicAccuracyMult = 0.2f;
    [SerializeField] private float catastrophicSpeedMult = 0.5f;
    [SerializeField] private float catastrophicHullDamage = 20f;

    [Header("Visual Settings")]
    [SerializeField] private float gizmoBarHeight = 3f;
    [SerializeField] private float gizmoBarWidth = 2f;
    [SerializeField] private float gizmoBarThickness = 0.2f;

    [Header("Debug Info")]
    [SerializeField] private float currentHeat = 0f;
    [SerializeField] private float plannedHeat = 0f;
    [SerializeField] private HeatTier currentTier = HeatTier.Safe;

    // Penalty lookup dictionaries (initialized in Awake)
    private Dictionary<HeatTier, HeatPenalties> penaltyLookup;
    private Dictionary<HeatTier, Color> colorLookup;

    // Events
    public event Action<float> OnHeatChanged;
    public event Action<HeatTier> OnHeatTierChanged;

    // Properties
    public float MaxHeat => maxHeat;
    public float CurrentHeat => currentHeat;
    public float PlannedHeat => plannedHeat;
    public float PassiveCooling => passiveCooling;

    /// <summary>
    /// Initialize lookup tables on Awake.
    /// </summary>
    private void Awake()
    {
        InitializePenaltyLookup();
        InitializeColorLookup();
    }

    /// <summary>
    /// Initialize heat system.
    /// </summary>
    private void Start()
    {
        currentHeat = 0f;
        plannedHeat = 0f;
        currentTier = HeatTier.Safe;
    }

    /// <summary>
    /// Initialize the penalty lookup dictionary with serialized values.
    /// </summary>
    private void InitializePenaltyLookup()
    {
        penaltyLookup = new Dictionary<HeatTier, HeatPenalties>
        {
            { HeatTier.Safe, CreatePenalty(1.0f, 1.0f, 0f, false) },
            { HeatTier.Minor, CreatePenalty(minorAccuracyMult, minorSpeedMult, 0f, false) },
            { HeatTier.Moderate, CreatePenalty(moderateAccuracyMult, moderateSpeedMult, 0f, true) },
            { HeatTier.Severe, CreatePenalty(severeAccuracyMult, severeSpeedMult, 0f, true) },
            { HeatTier.Critical, CreatePenalty(criticalAccuracyMult, criticalSpeedMult, criticalHullDamage, true) },
            { HeatTier.Catastrophic, CreatePenalty(catastrophicAccuracyMult, catastrophicSpeedMult, catastrophicHullDamage, true) }
        };
    }

    /// <summary>
    /// Initialize the color lookup dictionary.
    /// </summary>
    private void InitializeColorLookup()
    {
        colorLookup = new Dictionary<HeatTier, Color>
        {
            { HeatTier.Safe, new Color(0.0f, 1.0f, 0.0f, 1.0f) },        // Green
            { HeatTier.Minor, new Color(0.5f, 1.0f, 0.0f, 1.0f) },       // Yellow-green
            { HeatTier.Moderate, new Color(1.0f, 1.0f, 0.0f, 1.0f) },    // Yellow
            { HeatTier.Severe, new Color(1.0f, 0.5f, 0.0f, 1.0f) },      // Orange
            { HeatTier.Critical, new Color(1.0f, 0.0f, 0.0f, 1.0f) },    // Red
            { HeatTier.Catastrophic, new Color(0.5f, 0.0f, 0.0f, 1.0f) } // Dark red
        };
    }

    /// <summary>
    /// Helper to create HeatPenalties struct.
    /// </summary>
    private HeatPenalties CreatePenalty(float accuracy, float speed, float hullDamage, bool sensorFlicker)
    {
        return new HeatPenalties
        {
            AccuracyMultiplier = accuracy,
            SpeedMultiplier = speed,
            HullDamagePerTurn = hullDamage,
            SensorFlicker = sensorFlicker
        };
    }

    /// <summary>
    /// Adds heat to the planned heat pool (for UI preview).
    /// </summary>
    /// <param name="amount">Amount of heat to add</param>
    public void AddPlannedHeat(float amount)
    {
        plannedHeat += amount;
        OnHeatChanged?.Invoke(currentHeat + plannedHeat);
        Debug.Log($"{gameObject.name} - Planned heat: {plannedHeat:F1} (Total with current: {currentHeat + plannedHeat:F1})");
    }

    /// <summary>
    /// Commits ALL planned heat to current heat (when all actions execute).
    /// </summary>
    public void CommitPlannedHeat()
    {
        currentHeat += plannedHeat;
        plannedHeat = 0f;

        // Clamp to max heat (allow overheat up to multiplier)
        currentHeat = Mathf.Min(currentHeat, maxHeat * overheatMultiplier);

        UpdateHeatTier();
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Heat committed. Current: {currentHeat:F1}, Tier: {currentTier}");
    }

    /// <summary>
    /// Commits a specific amount of planned heat to current heat (when a specific action executes).
    /// </summary>
    /// <param name="amount">Amount of heat to commit from planned to current</param>
    public void CommitSpecificHeat(float amount)
    {
        float heatToCommit = Mathf.Min(amount, plannedHeat);
        currentHeat += heatToCommit;
        plannedHeat = Mathf.Max(0f, plannedHeat - heatToCommit);

        // Clamp to max heat (allow overheat up to multiplier)
        currentHeat = Mathf.Min(currentHeat, maxHeat * overheatMultiplier);

        UpdateHeatTier();
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Committed {heatToCommit} heat. Current: {currentHeat:F1}, Planned remaining: {plannedHeat:F1}, Tier: {currentTier}");
    }

    /// <summary>
    /// Clears ALL planned heat (if all actions are cancelled).
    /// </summary>
    public void ClearPlannedHeat()
    {
        plannedHeat = 0f;
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Planned heat cleared");
    }

    /// <summary>
    /// Removes a specific amount of planned heat (if a specific action is cancelled).
    /// </summary>
    /// <param name="amount">Amount of planned heat to remove</param>
    public void RemovePlannedHeat(float amount)
    {
        plannedHeat = Mathf.Max(0f, plannedHeat - amount);
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Removed {amount} planned heat. Remaining planned: {plannedHeat:F1}");
    }

    /// <summary>
    /// Applies passive cooling to reduce current heat.
    /// Called at the end of each turn.
    /// </summary>
    public void ApplyPassiveCooling()
    {
        float previousHeat = currentHeat;
        currentHeat = Mathf.Max(0f, currentHeat - passiveCooling);

        if (Mathf.Abs(previousHeat - currentHeat) > 0.01f)
        {
            UpdateHeatTier();
            OnHeatChanged?.Invoke(currentHeat);
            Debug.Log($"{gameObject.name} - Passive cooling applied. Heat: {previousHeat:F1} → {currentHeat:F1}");
        }
    }

    /// <summary>
    /// Applies instant cooling (from abilities or items).
    /// </summary>
    /// <param name="amount">Amount of heat to remove</param>
    public void InstantCooling(float amount)
    {
        float previousHeat = currentHeat;
        currentHeat = Mathf.Max(0f, currentHeat - amount);

        UpdateHeatTier();
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Instant cooling: -{amount:F1}. Heat: {previousHeat:F1} → {currentHeat:F1}");
    }

    /// <summary>
    /// Gets the current heat tier based on current heat level.
    /// </summary>
    /// <returns>Current HeatTier enum</returns>
    public HeatTier GetCurrentTier()
    {
        return currentTier;
    }

    /// <summary>
    /// Gets the current penalties based on heat level.
    /// Uses dictionary lookup for O(1) performance.
    /// </summary>
    /// <returns>HeatPenalties struct with current multipliers</returns>
    public HeatPenalties GetPenalties()
    {
        // Ensure lookup is initialized (for cases where called before Awake)
        if (penaltyLookup == null)
        {
            InitializePenaltyLookup();
        }

        return penaltyLookup.TryGetValue(currentTier, out HeatPenalties penalties)
            ? penalties
            : CreatePenalty(1.0f, 1.0f, 0f, false);
    }

    /// <summary>
    /// Updates the current heat tier and fires event if tier changed.
    /// </summary>
    private void UpdateHeatTier()
    {
        HeatTier previousTier = currentTier;
        currentTier = CalculateHeatTier(currentHeat);

        if (currentTier != previousTier)
        {
            OnHeatTierChanged?.Invoke(currentTier);
            Debug.Log($"{gameObject.name} - Heat tier changed: {previousTier} → {currentTier}");
        }
    }

    /// <summary>
    /// Calculates heat tier based on heat value.
    /// </summary>
    /// <param name="heat">Heat value to check</param>
    /// <returns>Corresponding HeatTier</returns>
    private HeatTier CalculateHeatTier(float heat)
    {
        if (heat >= catastrophicThreshold) return HeatTier.Catastrophic;
        if (heat >= criticalThreshold) return HeatTier.Critical;
        if (heat >= severeThreshold) return HeatTier.Severe;
        if (heat >= moderateThreshold) return HeatTier.Moderate;
        if (heat >= minorThreshold) return HeatTier.Minor;
        return HeatTier.Safe;
    }

    /// <summary>
    /// Gets the color associated with the current heat tier.
    /// Uses dictionary lookup for O(1) performance.
    /// </summary>
    /// <returns>Color for current tier</returns>
    public Color GetTierColor()
    {
        // Ensure lookup is initialized (for cases where called before Awake)
        if (colorLookup == null)
        {
            InitializeColorLookup();
        }

        return colorLookup.TryGetValue(currentTier, out Color color) ? color : Color.white;
    }

    /// <summary>
    /// Draws debug gizmos for heat visualization.
    /// </summary>
    private void OnDrawGizmosSelected()
    {
        // Draw heat bar above ship
        Vector3 barPosition = transform.position + Vector3.up * gizmoBarHeight;

        // Background
        Gizmos.color = Color.gray;
        Gizmos.DrawCube(barPosition, new Vector3(gizmoBarWidth, gizmoBarThickness, 0.1f));

        // Current heat
        float heatPercentage = currentHeat / maxHeat;
        float fillWidth = gizmoBarWidth * heatPercentage;
        Gizmos.color = GetTierColor();
        Gizmos.DrawCube(barPosition - Vector3.right * (gizmoBarWidth - fillWidth) * 0.5f,
            new Vector3(fillWidth, gizmoBarThickness, 0.11f));
    }
}
