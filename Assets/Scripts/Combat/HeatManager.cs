using UnityEngine;
using System;

/// <summary>
/// Manages heat generation, accumulation, and cooling for a ship.
/// Heat is generated by weapons and abilities, and applies escalating penalties.
/// </summary>
public class HeatManager : MonoBehaviour
{
    /// <summary>
    /// Heat tier thresholds that determine penalty severity.
    /// </summary>
    public enum HeatTier
    {
        Safe,           // 0-59: No penalties
        Minor,          // 60-79: -10% accuracy
        Moderate,       // 80-99: -20% accuracy, -10% speed, sensor flicker
        Severe,         // 100-119: -40% accuracy, -25% speed, systems glitching
        Critical,       // 120-149: -60% accuracy, -40% speed, 5 hull dmg/turn
        Catastrophic    // 150+: -80% accuracy, -50% speed, 20 hull dmg/turn
    }

    /// <summary>
    /// Struct containing all current heat-based penalties.
    /// </summary>
    public struct HeatPenalties
    {
        public float AccuracyMultiplier;    // 1.0 to 0.2
        public float SpeedMultiplier;       // 1.0 to 0.5
        public float HullDamagePerTurn;     // 0 to 20
        public bool SensorFlicker;          // Visual effect flag
    }

    [Header("Heat Configuration")]
    [SerializeField] private float maxHeat = 150f;
    [SerializeField] private float passiveCooling = 20f;

    [Header("Debug Info")]
    [SerializeField] private float currentHeat = 0f;
    [SerializeField] private float plannedHeat = 0f;
    [SerializeField] private HeatTier currentTier = HeatTier.Safe;

    // Events
    public event Action<float> OnHeatChanged;
    public event Action<HeatTier> OnHeatTierChanged;

    // Properties
    public float MaxHeat => maxHeat;
    public float CurrentHeat => currentHeat;
    public float PlannedHeat => plannedHeat;
    public float PassiveCooling => passiveCooling;

    /// <summary>
    /// Initialize heat system.
    /// </summary>
    private void Start()
    {
        currentHeat = 0f;
        plannedHeat = 0f;
        currentTier = HeatTier.Safe;
    }

    /// <summary>
    /// Adds heat to the planned heat pool (for UI preview).
    /// </summary>
    /// <param name="amount">Amount of heat to add</param>
    public void AddPlannedHeat(float amount)
    {
        plannedHeat += amount;
        OnHeatChanged?.Invoke(currentHeat + plannedHeat);
        Debug.Log($"{gameObject.name} - Planned heat: {plannedHeat:F1} (Total with current: {currentHeat + plannedHeat:F1})");
    }

    /// <summary>
    /// Commits ALL planned heat to current heat (when all actions execute).
    /// </summary>
    public void CommitPlannedHeat()
    {
        currentHeat += plannedHeat;
        plannedHeat = 0f;

        // Clamp to max heat
        currentHeat = Mathf.Min(currentHeat, maxHeat * 2f); // Allow overheat up to 2x max

        UpdateHeatTier();
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Heat committed. Current: {currentHeat:F1}, Tier: {currentTier}");
    }

    /// <summary>
    /// Commits a specific amount of planned heat to current heat (when a specific action executes).
    /// </summary>
    /// <param name="amount">Amount of heat to commit from planned to current</param>
    public void CommitSpecificHeat(float amount)
    {
        float heatToCommit = Mathf.Min(amount, plannedHeat);
        currentHeat += heatToCommit;
        plannedHeat = Mathf.Max(0f, plannedHeat - heatToCommit);

        // Clamp to max heat
        currentHeat = Mathf.Min(currentHeat, maxHeat * 2f);

        UpdateHeatTier();
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Committed {heatToCommit} heat. Current: {currentHeat:F1}, Planned remaining: {plannedHeat:F1}, Tier: {currentTier}");
    }

    /// <summary>
    /// Clears ALL planned heat (if all actions are cancelled).
    /// </summary>
    public void ClearPlannedHeat()
    {
        plannedHeat = 0f;
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Planned heat cleared");
    }

    /// <summary>
    /// Removes a specific amount of planned heat (if a specific action is cancelled).
    /// </summary>
    /// <param name="amount">Amount of planned heat to remove</param>
    public void RemovePlannedHeat(float amount)
    {
        plannedHeat = Mathf.Max(0f, plannedHeat - amount);
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Removed {amount} planned heat. Remaining planned: {plannedHeat:F1}");
    }

    /// <summary>
    /// Applies passive cooling to reduce current heat.
    /// Called at the end of each turn.
    /// </summary>
    public void ApplyPassiveCooling()
    {
        float previousHeat = currentHeat;
        currentHeat = Mathf.Max(0f, currentHeat - passiveCooling);

        if (Mathf.Abs(previousHeat - currentHeat) > 0.01f)
        {
            UpdateHeatTier();
            OnHeatChanged?.Invoke(currentHeat);
            Debug.Log($"{gameObject.name} - Passive cooling applied. Heat: {previousHeat:F1} → {currentHeat:F1}");
        }
    }

    /// <summary>
    /// Applies instant cooling (from abilities or items).
    /// </summary>
    /// <param name="amount">Amount of heat to remove</param>
    public void InstantCooling(float amount)
    {
        float previousHeat = currentHeat;
        currentHeat = Mathf.Max(0f, currentHeat - amount);

        UpdateHeatTier();
        OnHeatChanged?.Invoke(currentHeat);
        Debug.Log($"{gameObject.name} - Instant cooling: -{amount:F1}. Heat: {previousHeat:F1} → {currentHeat:F1}");
    }

    /// <summary>
    /// Gets the current heat tier based on current heat level.
    /// </summary>
    /// <returns>Current HeatTier enum</returns>
    public HeatTier GetCurrentTier()
    {
        return currentTier;
    }

    /// <summary>
    /// Gets the current penalties based on heat level.
    /// </summary>
    /// <returns>HeatPenalties struct with current multipliers</returns>
    public HeatPenalties GetPenalties()
    {
        HeatPenalties penalties = new HeatPenalties();

        switch (currentTier)
        {
            case HeatTier.Safe:
                penalties.AccuracyMultiplier = 1.0f;
                penalties.SpeedMultiplier = 1.0f;
                penalties.HullDamagePerTurn = 0f;
                penalties.SensorFlicker = false;
                break;

            case HeatTier.Minor:
                penalties.AccuracyMultiplier = 0.9f; // -10%
                penalties.SpeedMultiplier = 1.0f;
                penalties.HullDamagePerTurn = 0f;
                penalties.SensorFlicker = false;
                break;

            case HeatTier.Moderate:
                penalties.AccuracyMultiplier = 0.8f; // -20%
                penalties.SpeedMultiplier = 0.9f; // -10%
                penalties.HullDamagePerTurn = 0f;
                penalties.SensorFlicker = true;
                break;

            case HeatTier.Severe:
                penalties.AccuracyMultiplier = 0.6f; // -40%
                penalties.SpeedMultiplier = 0.75f; // -25%
                penalties.HullDamagePerTurn = 0f;
                penalties.SensorFlicker = true;
                break;

            case HeatTier.Critical:
                penalties.AccuracyMultiplier = 0.4f; // -60%
                penalties.SpeedMultiplier = 0.6f; // -40%
                penalties.HullDamagePerTurn = 5f;
                penalties.SensorFlicker = true;
                break;

            case HeatTier.Catastrophic:
                penalties.AccuracyMultiplier = 0.2f; // -80%
                penalties.SpeedMultiplier = 0.5f; // -50%
                penalties.HullDamagePerTurn = 20f;
                penalties.SensorFlicker = true;
                break;

            default:
                penalties.AccuracyMultiplier = 1.0f;
                penalties.SpeedMultiplier = 1.0f;
                penalties.HullDamagePerTurn = 0f;
                penalties.SensorFlicker = false;
                break;
        }

        return penalties;
    }

    /// <summary>
    /// Updates the current heat tier and fires event if tier changed.
    /// </summary>
    private void UpdateHeatTier()
    {
        HeatTier previousTier = currentTier;
        currentTier = CalculateHeatTier(currentHeat);

        if (currentTier != previousTier)
        {
            OnHeatTierChanged?.Invoke(currentTier);
            Debug.Log($"{gameObject.name} - Heat tier changed: {previousTier} → {currentTier}");
        }
    }

    /// <summary>
    /// Calculates heat tier based on heat value.
    /// </summary>
    /// <param name="heat">Heat value to check</param>
    /// <returns>Corresponding HeatTier</returns>
    private HeatTier CalculateHeatTier(float heat)
    {
        if (heat >= 150f) return HeatTier.Catastrophic;
        if (heat >= 120f) return HeatTier.Critical;
        if (heat >= 100f) return HeatTier.Severe;
        if (heat >= 80f) return HeatTier.Moderate;
        if (heat >= 60f) return HeatTier.Minor;
        return HeatTier.Safe;
    }

    /// <summary>
    /// Gets the color associated with the current heat tier.
    /// Used for UI visualization.
    /// </summary>
    /// <returns>Color for current tier</returns>
    public Color GetTierColor()
    {
        switch (currentTier)
        {
            case HeatTier.Safe:
                return new Color(0.0f, 1.0f, 0.0f, 1.0f); // Green
            case HeatTier.Minor:
                return new Color(0.5f, 1.0f, 0.0f, 1.0f); // Yellow-green
            case HeatTier.Moderate:
                return new Color(1.0f, 1.0f, 0.0f, 1.0f); // Yellow
            case HeatTier.Severe:
                return new Color(1.0f, 0.5f, 0.0f, 1.0f); // Orange
            case HeatTier.Critical:
                return new Color(1.0f, 0.0f, 0.0f, 1.0f); // Red
            case HeatTier.Catastrophic:
                return new Color(0.5f, 0.0f, 0.0f, 1.0f); // Dark red
            default:
                return Color.white;
        }
    }

    /// <summary>
    /// Draws debug gizmos for heat visualization.
    /// </summary>
    private void OnDrawGizmosSelected()
    {
        // Draw heat bar above ship
        Vector3 barPosition = transform.position + Vector3.up * 3f;
        float barWidth = 2f;
        float barHeight = 0.2f;

        // Background
        Gizmos.color = Color.gray;
        Gizmos.DrawCube(barPosition, new Vector3(barWidth, barHeight, 0.1f));

        // Current heat
        float heatPercentage = currentHeat / maxHeat;
        float fillWidth = barWidth * heatPercentage;
        Gizmos.color = GetTierColor();
        Gizmos.DrawCube(barPosition - Vector3.right * (barWidth - fillWidth) * 0.5f,
            new Vector3(fillWidth, barHeight, 0.11f));
    }
}
